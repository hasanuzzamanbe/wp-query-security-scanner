<?php
/**
 * Vulnerability Detector Class
 * 
 * Advanced detection engine for security vulnerabilities
 */

if (!defined('ABSPATH')) {
    exit('Direct access denied.');
}

class WPQSS_Vulnerability_Detector {
    
    private $patterns;
    private $scan_progress;
    private $current_user_id;
    
    public function __construct() {
        $this->patterns = WPQSS_Security_Patterns::get_patterns();
        $this->current_user_id = get_current_user_id();
    }
    
    /**
     * Scan a directory for vulnerabilities
     *
     * @param string $directory
     * @param string $type
     * @param string $specific_component Optional specific plugin/theme to scan
     * @return array
     */
    public function scan_directory($directory, $type = 'plugins', $specific_component = null) {
        // Increase execution time and memory for large scans
        $this->prepare_for_scan();

        $this->init_scan_progress();

        $results = [];
        $files = $this->get_php_files($directory, $specific_component);
        $total_files = count($files);
        $processed = 0;

        // Process files in batches to prevent timeouts
        $batch_size = 50; // Process 50 files at a time
        $batches = array_chunk($files, $batch_size);

        foreach ($batches as $batch_index => $batch) {
            foreach ($batch as $file) {
                // Check if we're approaching time limit
                if ($this->is_approaching_time_limit()) {
                    $this->update_scan_progress($processed, $total_files, "Scan paused due to time limit");
                    break 2; // Break out of both loops
                }

                $vulnerabilities = $this->scan_file($file);

                if (!empty($vulnerabilities)) {
                    $relative_path = str_replace($directory, '', $file);
                    $component_name = $this->get_component_name($file, $directory, $type);

                    if (!isset($results[$component_name])) {
                        $results[$component_name] = [
                            'name' => $component_name,
                            'type' => $type,
                            'files' => [],
                            'total_vulnerabilities' => 0,
                            'severity_counts' => [
                                'critical' => 0,
                                'high' => 0,
                                'medium' => 0,
                                'low' => 0
                            ]
                        ];
                    }

                    $results[$component_name]['files'][] = [
                        'file' => $relative_path,
                        'full_path' => $file,
                        'vulnerabilities' => $vulnerabilities
                    ];

                    // Update counts
                    foreach ($vulnerabilities as $vuln) {
                        $results[$component_name]['total_vulnerabilities']++;
                        $results[$component_name]['severity_counts'][$vuln['severity']]++;
                    }
                }

                $processed++;

                // Update progress every 10 files to reduce overhead
                if ($processed % 10 === 0 || $processed === $total_files) {
                    $this->update_scan_progress($processed, $total_files, "Scanning: " . basename($file));
                }
            }

            // Small delay between batches to prevent overwhelming the server
            if ($batch_index < count($batches) - 1) {
                usleep(100000); // 0.1 second delay
            }
        }

        $this->complete_scan_progress();

        // Sort results by severity
        foreach ($results as &$component) {
            usort($component['files'], function($a, $b) {
                return $this->compare_by_severity($a['vulnerabilities'], $b['vulnerabilities']);
            });
        }

        return array_values($results);
    }
    
    /**
     * Scan a single file for vulnerabilities
     *
     * @param string $file_path
     * @return array
     */
    public function scan_file($file_path) {
        if (!file_exists($file_path) || !is_readable($file_path)) {
            return [];
        }

        // Skip very large files to prevent memory issues
        $file_size = filesize($file_path);
        if ($file_size > 2097152) { // 2MB limit
            return [];
        }

        $content = file_get_contents($file_path);
        if ($content === false || empty($content)) {
            return [];
        }

        // Skip binary files
        if (!mb_check_encoding($content, 'UTF-8') && !mb_check_encoding($content, 'ASCII')) {
            return [];
        }

        $lines = explode("\n", $content);
        $vulnerabilities = [];

        // Limit processing time per file
        $start_time = microtime(true);
        $max_processing_time = 5; // 5 seconds per file

        foreach ($this->patterns as $category => $category_patterns) {
            // Check processing time
            if (microtime(true) - $start_time > $max_processing_time) {
                break;
            }

            foreach ($category_patterns as $pattern_data) {
                try {
                    $matches = $this->find_pattern_matches($content, $pattern_data['pattern']);

                    foreach ($matches as $match) {
                        $line_number = $this->get_line_number($content, $match['offset']);
                        $context = $this->get_code_context($lines, $line_number);

                        $vulnerabilities[] = [
                            'category' => $category,
                            'type' => $this->format_category_name($category),
                            'severity' => $pattern_data['severity'],
                            'description' => $pattern_data['description'],
                            'remediation' => $pattern_data['remediation'],
                            'line' => $line_number,
                            'code' => trim($match['match']),
                            'context' => $context,
                            'file_path' => $file_path
                        ];
                    }
                } catch (Exception $e) {
                    // Log pattern matching errors but continue
                    error_log('WPQSS: Pattern matching error in ' . $file_path . ': ' . $e->getMessage());
                    continue;
                }
            }
        }

        // Remove duplicates and sort by line number
        $vulnerabilities = $this->remove_duplicate_vulnerabilities($vulnerabilities);
        usort($vulnerabilities, function($a, $b) {
            return $a['line'] - $b['line'];
        });

        return $vulnerabilities;
    }
    
    /**
     * Find pattern matches in content
     * 
     * @param string $content
     * @param string $pattern
     * @return array
     */
    private function find_pattern_matches($content, $pattern) {
        $matches = [];
        
        if (preg_match_all($pattern, $content, $pattern_matches, PREG_OFFSET_CAPTURE)) {
            foreach ($pattern_matches[0] as $match) {
                $matches[] = [
                    'match' => $match[0],
                    'offset' => $match[1]
                ];
            }
        }
        
        return $matches;
    }
    
    /**
     * Get line number from content offset
     * 
     * @param string $content
     * @param int $offset
     * @return int
     */
    private function get_line_number($content, $offset) {
        return substr_count(substr($content, 0, $offset), "\n") + 1;
    }
    
    /**
     * Get code context around a line
     * 
     * @param array $lines
     * @param int $line_number
     * @param int $context_lines
     * @return array
     */
    private function get_code_context($lines, $line_number, $context_lines = 3) {
        $start = max(0, $line_number - $context_lines - 1);
        $end = min(count($lines) - 1, $line_number + $context_lines - 1);
        
        $context = [];
        for ($i = $start; $i <= $end; $i++) {
            $context[] = [
                'line_number' => $i + 1,
                'code' => $lines[$i] ?? '',
                'is_vulnerable' => ($i + 1) === $line_number
            ];
        }
        
        return $context;
    }
    
    /**
     * Get all PHP files in directory recursively
     *
     * @param string $directory
     * @param string $specific_component Optional specific component to scan
     * @return array
     */
    private function get_php_files($directory, $specific_component = null) {
        $files = [];

        try {
            if ($specific_component) {
                // Scan only specific plugin/theme
                $component_path = $directory . '/' . $specific_component;
                if (!is_dir($component_path)) {
                    return [];
                }
                $directory = $component_path;
            }

            $iterator = new RecursiveIteratorIterator(
                new RecursiveDirectoryIterator($directory, RecursiveDirectoryIterator::SKIP_DOTS),
                RecursiveIteratorIterator::LEAVES_ONLY
            );

            foreach ($iterator as $file) {
                if ($file->isFile() && $file->getExtension() === 'php') {
                    // Skip very large files (>1MB) to prevent memory issues
                    if ($file->getSize() > 1048576) {
                        continue;
                    }
                    $files[] = $file->getPathname();
                }
            }
        } catch (Exception $e) {
            error_log('WPQSS: Error scanning directory: ' . $e->getMessage());
        }

        return $files;
    }
    
    /**
     * Get component name from file path
     * 
     * @param string $file_path
     * @param string $base_directory
     * @param string $type
     * @return string
     */
    private function get_component_name($file_path, $base_directory, $type) {
        $relative_path = str_replace($base_directory . '/', '', $file_path);
        $parts = explode('/', $relative_path);
        
        if ($type === 'themes') {
            return $parts[0] ?? 'Unknown Theme';
        } else {
            return $parts[0] ?? 'Unknown Plugin';
        }
    }
    
    /**
     * Format category name for display
     * 
     * @param string $category
     * @return string
     */
    private function format_category_name($category) {
        $names = [
            'sql_injection' => 'SQL Injection',
            'xss' => 'Cross-Site Scripting (XSS)',
            'csrf' => 'Cross-Site Request Forgery (CSRF)',
            'file_inclusion' => 'File Inclusion',
            'privilege_escalation' => 'Privilege Escalation',
            'information_disclosure' => 'Information Disclosure',
            'unsafe_deserialization' => 'Unsafe Deserialization',
            'command_injection' => 'Command Injection'
        ];
        
        return $names[$category] ?? ucwords(str_replace('_', ' ', $category));
    }
    
    /**
     * Remove duplicate vulnerabilities
     * 
     * @param array $vulnerabilities
     * @return array
     */
    private function remove_duplicate_vulnerabilities($vulnerabilities) {
        $unique = [];
        $seen = [];
        
        foreach ($vulnerabilities as $vuln) {
            $key = $vuln['line'] . '|' . $vuln['category'] . '|' . md5($vuln['code']);
            if (!isset($seen[$key])) {
                $seen[$key] = true;
                $unique[] = $vuln;
            }
        }
        
        return $unique;
    }
    
    /**
     * Compare vulnerabilities by severity
     * 
     * @param array $vulns_a
     * @param array $vulns_b
     * @return int
     */
    private function compare_by_severity($vulns_a, $vulns_b) {
        $max_severity_a = 0;
        $max_severity_b = 0;
        
        foreach ($vulns_a as $vuln) {
            $priority = WPQSS_Security_Patterns::get_severity_priority($vuln['severity']);
            if ($priority > $max_severity_a) {
                $max_severity_a = $priority;
            }
        }
        
        foreach ($vulns_b as $vuln) {
            $priority = WPQSS_Security_Patterns::get_severity_priority($vuln['severity']);
            if ($priority > $max_severity_b) {
                $max_severity_b = $priority;
            }
        }
        
        return $max_severity_b - $max_severity_a;
    }
    
    /**
     * Initialize scan progress tracking
     */
    private function init_scan_progress() {
        $this->scan_progress = [
            'progress' => 0,
            'status' => 'scanning',
            'message' => 'Initializing scan...',
            'start_time' => time()
        ];
        
        set_transient('wpqss_scan_progress_' . $this->current_user_id, $this->scan_progress, 300);
    }
    
    /**
     * Update scan progress
     * 
     * @param int $processed
     * @param int $total
     * @param string $message
     */
    private function update_scan_progress($processed, $total, $message = '') {
        $this->scan_progress['progress'] = round(($processed / $total) * 100);
        $this->scan_progress['message'] = $message;
        
        set_transient('wpqss_scan_progress_' . $this->current_user_id, $this->scan_progress, 300);
    }
    
    /**
     * Complete scan progress
     */
    private function complete_scan_progress() {
        $this->scan_progress['progress'] = 100;
        $this->scan_progress['status'] = 'complete';
        $this->scan_progress['message'] = 'Scan completed';
        $this->scan_progress['end_time'] = time();

        set_transient('wpqss_scan_progress_' . $this->current_user_id, $this->scan_progress, 300);
    }

    /**
     * Prepare environment for scanning
     */
    private function prepare_for_scan() {
        // Increase execution time (but respect server limits)
        $current_limit = ini_get('max_execution_time');
        if ($current_limit > 0 && $current_limit < 300) {
            @set_time_limit(300); // 5 minutes max
        }

        // Increase memory limit if needed
        $current_memory = ini_get('memory_limit');
        if ($this->convert_to_bytes($current_memory) < 268435456) { // 256MB
            @ini_set('memory_limit', '256M');
        }
    }

    /**
     * Check if we're approaching PHP execution time limit
     */
    private function is_approaching_time_limit() {
        if (!isset($this->scan_progress['start_time'])) {
            return false;
        }

        $max_execution_time = ini_get('max_execution_time');
        if ($max_execution_time <= 0) {
            return false; // No time limit
        }

        $elapsed = time() - $this->scan_progress['start_time'];
        $threshold = $max_execution_time * 0.8; // 80% of max time

        return $elapsed > $threshold;
    }

    /**
     * Convert memory limit string to bytes
     */
    private function convert_to_bytes($value) {
        $value = trim($value);
        $last = strtolower($value[strlen($value) - 1]);
        $value = (int) $value;

        switch ($last) {
            case 'g':
                $value *= 1024;
            case 'm':
                $value *= 1024;
            case 'k':
                $value *= 1024;
        }

        return $value;
    }

    /**
     * Get list of available plugins for specific scanning
     */
    public function get_available_plugins() {
        $plugins = [];
        $plugins_dir = WP_PLUGIN_DIR;

        if (is_dir($plugins_dir)) {
            $dirs = glob($plugins_dir . '/*', GLOB_ONLYDIR);
            foreach ($dirs as $dir) {
                $plugin_name = basename($dir);
                $plugin_file = $dir . '/' . $plugin_name . '.php';

                // Check if main plugin file exists
                if (file_exists($plugin_file)) {
                    $plugin_data = get_file_data($plugin_file, [
                        'Name' => 'Plugin Name',
                        'Version' => 'Version',
                        'Description' => 'Description'
                    ]);

                    $plugins[$plugin_name] = [
                        'name' => $plugin_data['Name'] ?: $plugin_name,
                        'version' => $plugin_data['Version'] ?: 'Unknown',
                        'description' => $plugin_data['Description'] ?: '',
                        'folder' => $plugin_name
                    ];
                }
            }
        }

        return $plugins;
    }

    /**
     * Get list of available themes for specific scanning
     */
    public function get_available_themes() {
        $themes = [];
        $themes_dir = WP_CONTENT_DIR . '/themes';

        if (is_dir($themes_dir)) {
            $dirs = glob($themes_dir . '/*', GLOB_ONLYDIR);
            foreach ($dirs as $dir) {
                $theme_name = basename($dir);
                $style_file = $dir . '/style.css';

                if (file_exists($style_file)) {
                    $theme_data = get_file_data($style_file, [
                        'Name' => 'Theme Name',
                        'Version' => 'Version',
                        'Description' => 'Description'
                    ]);

                    $themes[$theme_name] = [
                        'name' => $theme_data['Name'] ?: $theme_name,
                        'version' => $theme_data['Version'] ?: 'Unknown',
                        'description' => $theme_data['Description'] ?: '',
                        'folder' => $theme_name
                    ];
                }
            }
        }

        return $themes;
    }
}
